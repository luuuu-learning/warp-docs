---
sidebar_position: 2
---

# How it works


use cosmwasm_std::{to_vec, Binary, ContractResult, Decimal256, Deps, Env, StdError, SystemResult, Uint256};
use cosmwasm_std::{QueryRequest, WasmQuery};
use cw_storage_plus::KeyDeserialize;
use json_codec_wasm::ast::Ref;
use json_codec_wasm::Decoder;
use std::str::FromStr;
use warp_protocol::keeper::{Condition, TimeExpr};
use warp_protocol::keeper::Expr;
use warp_protocol::keeper::QueryExpr;
use warp_protocol::keeper::StringOp;
use warp_protocol::keeper::{GenExpr, NumOp, Value};

pub fn resolve_cond(deps: Deps, env: Env, cond: Condition) -> bool {
    match cond {
        Condition::And(conds) => conds
            .into_iter()
            .all(|cond| resolve_cond(deps, env.clone(), *cond)),
        Condition::Or(conds) => conds
            .into_iter()
            .any(|cond| resolve_cond(deps, env.clone(), *cond)),
        Condition::Not(cond) => !resolve_cond(deps, env, *cond),
        Condition::Expr(expr) => resolve_expr(deps, env, expr),
    }
}

pub fn resolve_expr(deps: Deps, env: Env, expr: Expr) -> bool {
    match expr {
        Expr::String(expr) => resolve_string_expr(deps, env, expr),
        Expr::Uint(expr) => resolve_uint_expr(deps, env, expr),
        Expr::Int(expr) => resolve_int_expr(deps, env, expr),
        Expr::Decimal(expr) => resolve_decimal_expr(deps, env, expr),
        Expr::Timestamp(expr) => resolve_timestamp_expr(deps, env, expr),
        Expr::BlockHeight(expr) => resolve_block_expr(deps, env, expr),
        Expr::Bool(expr) => resolve_query_expr_bool(deps, env, expr),
    }
}

pub fn resolve_uint_expr(deps: Deps, env: Env, expr: GenExpr<Value<Uint256>, NumOp>) -> bool {
    match (expr.left, expr.right) {
        (Value::Simple(left), Value::Simple(right)) => {
            resolve_uint_op(deps, env, left, right, expr.op)
        }
        (Value::Simple(left), Value::Query(right)) => resolve_uint_op(
            deps,
            env.clone(),
            left,
            resolve_query_expr_uint(deps, env, right),
            expr.op,
        ),
        (Value::Query(left), Value::Simple(right)) => resolve_uint_op(
            deps,
            env.clone(),
            resolve_query_expr_uint(deps, env, left),
            right,
            expr.op,
        ),
        (Value::Query(left), Value::Query(right)) => resolve_uint_op(
            deps,
            env.clone(),
            resolve_query_expr_uint(deps, env.clone(), left),
            resolve_query_expr_uint(deps, env, right),
            expr.op,
        ),
    }
}

pub fn resolve_int_expr(deps: Deps, env: Env, expr: GenExpr<Value<i128>, NumOp>) -> bool {
    match (expr.left, expr.right) {
        (Value::Simple(left), Value::Simple(right)) => {
            resolve_int_op(deps, env, left, right, expr.op)
        }
        (Value::Simple(left), Value::Query(right)) => resolve_int_op(
            deps,
            env.clone(),
            left,
            resolve_query_expr_int(deps, env, right),
            expr.op,
        ),
        (Value::Query(left), Value::Simple(right)) => resolve_int_op(
            deps,
            env.clone(),
            resolve_query_expr_int(deps, env, left),
            right,
            expr.op,
        ),
        (Value::Query(left), Value::Query(right)) => resolve_int_op(
            deps,
            env.clone(),
            resolve_query_expr_int(deps, env.clone(), left),
            resolve_query_expr_int(deps, env, right),
            expr.op,
        ),
    }
}

pub fn resolve_decimal_expr(deps: Deps, env: Env, expr: GenExpr<Value<Decimal256>, NumOp>) -> bool {
    match (expr.left, expr.right) {
        (Value::Simple(left), Value::Simple(right)) => {
            resolve_decimal_op(deps, env, left, right, expr.op)
        }
        (Value::Simple(left), Value::Query(right)) => resolve_decimal_op(
            deps,
            env.clone(),
            left,
            resolve_query_expr_decimal(deps, env, right),
            expr.op,
        ),
        (Value::Query(left), Value::Simple(right)) => resolve_decimal_op(
            deps,
            env.clone(),
            resolve_query_expr_decimal(deps, env, left),
            right,
            expr.op,
        ),
        (Value::Query(left), Value::Query(right)) => resolve_decimal_op(
            deps,
            env.clone(),
            resolve_query_expr_decimal(deps, env.clone(), left),
            resolve_query_expr_decimal(deps, env, right),
            expr.op,
        ),
    }
}

pub fn resolve_timestamp_expr(_deps: Deps, env: Env, expr: TimeExpr) -> bool {
    match expr.op {
        NumOp::Eq => expr.comparator.u64().eq(&env.block.time.seconds()),
        NumOp::Neq => expr.comparator.u64().ne(&env.block.time.seconds()),
        NumOp::Lt => expr.comparator.u64().lt(&env.block.time.seconds()),
        NumOp::Gt => expr.comparator.u64().gt(&env.block.time.seconds()),
        NumOp::Gte => expr.comparator.u64().ge(&env.block.time.seconds()),
        NumOp::Lte => expr.comparator.u64().le(&env.block.time.seconds()),
    }
}

pub fn resolve_block_expr(_deps: Deps, env: Env, expr: TimeExpr) -> bool {
    match expr.op {
        NumOp::Eq => expr.comparator.u64().eq(&env.block.height),
        NumOp::Neq => expr.comparator.u64().ne(&env.block.height),
        NumOp::Lt => expr.comparator.u64().lt(&env.block.height),
        NumOp::Gt => expr.comparator.u64().gt(&env.block.height),
        NumOp::Gte => expr.comparator.u64().ge(&env.block.height),
        NumOp::Lte => expr.comparator.u64().le(&env.block.height),
    }
}

pub fn resolve_uint_op(_deps: Deps, _env: Env, left: Uint256, right: Uint256, op: NumOp) -> bool {
    match op {
        NumOp::Eq => left.eq(&right),
        NumOp::Neq => left.ne(&right),
        NumOp::Lt => left.lt(&right),
        NumOp::Gt => left.gt(&right),
        NumOp::Gte => left.ge(&right),
        NumOp::Lte => left.le(&right),
    }
}

pub fn resolve_int_op(_deps: Deps, _env: Env, left: i128, right: i128, op: NumOp) -> bool {
    match op {
        NumOp::Eq => left.eq(&right),
        NumOp::Neq => left.ne(&right),
        NumOp::Lt => left.lt(&right),
        NumOp::Gt => left.gt(&right),
        NumOp::Gte => left.ge(&right),
        NumOp::Lte => left.le(&right),
    }
}

pub fn resolve_decimal_op(
    _deps: Deps,
    _env: Env,
    left: Decimal256,
    right: Decimal256,
    op: NumOp,
) -> bool {
    match op {
        NumOp::Eq => left.eq(&right),
        NumOp::Neq => left.ne(&right),
        NumOp::Lt => left.lt(&right),
        NumOp::Gt => left.gt(&right),
        NumOp::Gte => left.ge(&right),
        NumOp::Lte => left.le(&right),
    }
}

pub fn resolve_string_expr(deps: Deps, env: Env, expr: GenExpr<Value<String>, StringOp>) -> bool {
    match (expr.left, expr.right) {
        (Value::Simple(left), Value::Simple(right)) => {
            resolve_str_op(deps, env, left, right, expr.op)
        }
        (Value::Simple(left), Value::Query(right)) => resolve_str_op(
            deps,
            env.clone(),
            left,
            resolve_query_expr_string(deps, env, right),
            expr.op,
        ),
        (Value::Query(left), Value::Simple(right)) => resolve_str_op(
            deps,
            env.clone(),
            resolve_query_expr_string(deps, env, left),
            right,
            expr.op,
        ),
        (Value::Query(left), Value::Query(right)) => resolve_str_op(
            deps,
            env.clone(),
            resolve_query_expr_string(deps, env.clone(), left),
            resolve_query_expr_string(deps, env, right),
            expr.op,
        ),
    }
}

pub fn resolve_str_op(_deps: Deps, _env: Env, left: String, right: String, op: StringOp) -> bool {
    match op {
        StringOp::StartsWith => left.starts_with(&right),
        StringOp::EndsWith => left.ends_with(&right),
        StringOp::Contains => left.contains(&right),
        StringOp::Eq => left.eq(&right),
        StringOp::Neq => left.ne(&right),
    }
}

pub fn resolve_query_expr(deps: Deps, _env: Env, expr: QueryExpr) -> String {
    let raw = to_vec(&QueryRequest::<String>::Wasm(WasmQuery::Smart {
        contract_addr: expr.contract.to_string(),
        msg: Binary::from(expr.query.as_bytes()),
    }))
    .map_err(|serialize_err| {
        StdError::generic_err(format!("Serializing QueryRequest: {}", serialize_err))
    })
    .unwrap(); //todo: unwrap into ?

    let query_result_binary = match deps.querier.raw_query(&raw) {
        SystemResult::Err(system_err) => Err(StdError::generic_err(format!(
            "Querier system error: {}",
            system_err
        ))),
        SystemResult::Ok(ContractResult::Err(contract_err)) => Err(StdError::generic_err(format!(
            "Querier contract error: {}",
            contract_err
        ))),
        SystemResult::Ok(ContractResult::Ok(value)) => Ok(value),
    }
    .unwrap(); //todo: unwrap into ?

    let query_result_str =
        String::from_vec(base64::decode(query_result_binary.to_string()).unwrap()).unwrap(); //todo: unwrap into ?

    query_result_str
}

pub fn resolve_query_expr_bool(deps: Deps, env: Env, expr: QueryExpr) -> bool {
    let query_result_str = resolve_query_expr(deps, env, expr.clone());
    let value = Decoder::default(query_result_str.chars()).decode().unwrap(); //todo: unwrap into ?
    let r = Ref::new(&value);
    let resolved = resolve_path(r, expr.selector);

    resolved.bool().unwrap() //todo: unwrap into ?
}

pub fn resolve_query_expr_uint(deps: Deps, env: Env, expr: QueryExpr) -> Uint256 {
    let query_result_str = resolve_query_expr(deps, env, expr.clone());
    let value = Decoder::default(query_result_str.chars()).decode().unwrap(); //todo: unwrap into ?
    let r = Ref::new(&value);
    let resolved = resolve_path(r, expr.selector);

    Uint256::from_str(resolved.string().unwrap()).unwrap() //todo: unwrap into ?
}

pub fn resolve_query_expr_int(deps: Deps, env: Env, expr: QueryExpr) -> i128 {
    let query_result_str = resolve_query_expr(deps, env, expr.clone());
    let value = Decoder::default(query_result_str.chars()).decode().unwrap(); //todo: unwrap into ?
    let r = Ref::new(&value);
    let resolved = resolve_path(r, expr.selector);

    resolved.i128().unwrap() //todo: unwrap into ?
}

pub fn resolve_query_expr_decimal(deps: Deps, env: Env, expr: QueryExpr) -> Decimal256 {
    let query_result_str = resolve_query_expr(deps, env, expr.clone());
    let value = Decoder::default(query_result_str.chars()).decode().unwrap(); //todo: unwrap into ?
    let r = Ref::new(&value);
    let resolved = resolve_path(r, expr.selector);

    Decimal256::from_str(resolved.string().unwrap()).unwrap() //todo: unwrap into ?
}

pub fn resolve_query_expr_string(deps: Deps, env: Env, expr: QueryExpr) -> String {
    let query_result_str = resolve_query_expr(deps, env, expr.clone());
    let value = Decoder::default(query_result_str.chars()).decode().unwrap(); //todo: unwrap into ?
    let r = Ref::new(&value);
    let resolved = resolve_path(r, expr.selector);

    resolved.string().unwrap().to_string() //todo: unwrap into ?
}

// supports custom jsonpath-like expression with options for indexing
// - fields - $.field
// - array entries - $.field[0]
// - multiple nested fields / entries - $.field1.field2[0].field3
pub fn resolve_path(r: Ref, path: String) -> Ref {
    let mut obj = r;
    let mut curr = String::new();
    let mut idx = 0;

    while idx < path.len() {
        let c = path.chars().nth(idx).unwrap(); //todo: unwrap into ?

        match c {
            '$' => {
                idx += 1;
            }
            '[' => {
                // field[0] case
                if !curr.is_empty() {
                    obj = obj.get(curr);
                    curr = String::new();
                }

                let (new_idx, array_idx) = read_array_index(path, idx + 1);
                obj = obj.at(array_idx);
                idx = new_idx;
                break;
            }
            '.' => {
                // $ case
                if curr.is_empty() {
                    idx += 1;
                    continue;
                }

                obj = obj.get(curr);
                curr = String::new();
                idx += 1;
            }
            c => {
                curr.push(c);
                idx += 1;
            }
        }
    }

    if !curr.is_empty() {
        obj = obj.get(curr);
    }

    obj
}

fn read_array_index(path: String, from: usize) -> (usize, usize) {
    let mut idx = from;
    let mut curr = String::new();
    while path.chars().nth(idx).unwrap() != ']' {
        //todo: unwrap into ?
        curr.push(path.chars().nth(idx).unwrap()); //todo: unwrap into ?
        idx += 1;
    }

    return (idx + 1, str::parse::<usize>(curr.as_str()).unwrap()); //todo: unwrap into ?
}
